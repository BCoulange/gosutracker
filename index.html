<!DOCTYPE html>
<html lang="en">

<head>
  <meta name="description" content="Webpage description goes here" />
  <meta charset="utf-8">
  <title>Gosu X Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="">
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/underscore@1.13.6/underscore-umd-min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js" charset="utf-8"></script>
</head>

<body>


<script type="module">
  import { h, render } from 'https://esm.sh/preact';
  
  import htm from 'https://esm.sh/htm';
  import { useState, useEffect, useRef } from 'https://esm.sh/preact/hooks';

  const optimal_computation_min_dataset_size = 10

  const clans_classes = {
    "Xi'an":"xian",
    "Narashima":"narashima",
    "Abhilasha":"abhilasha",
    "Galmi":"galmi",
    "Tomorrow":"tomorrow",
    "Goan-Sul":"goan-sul",
    "Justice":"justice",
    "Phoenix":"phoenix",
    "Abunakkashii":"abunakkashii"
  }
  const clans_colors = {
    "Xi'an":"#d1ba24",
    "Narashima":"#d18324",
    "Abhilasha":"#5424ad",
    "Galmi":"#2a8014",
    "Tomorrow":"#a422b5",
    "Goan-Sul":"#911010",
    "Justice":"#a1a1a1",
    "Phoenix":"#0f33b8",
    "Abunakkashii":"#52473c"
  }
  const stats = ["lvl1_played","lvl2_played","lvl3_played","cards_drawn","cards_captured","cards_destroyed","cards_sacrificed","cards_shifted","force_of_will","activation_tokens"]

  function optimal_6th_clan_draft(data,current_selection,trials_prior = {size: 200, pct: 50},options = {}){
    const bayesian_prior = (options["bayesian_prior"] !== undefined) && (options["bayesian_prior"])
    const dataset = _.select(data,(d) => {
      return (d["clans_selected"][0] === current_selection[0]) 
        && ((d["clans_selected"][1] === current_selection[1]) || (d["clans_selected"][2] === current_selection[1]))
        && ((d["clans_selected"][1] === current_selection[2]) || (d["clans_selected"][2] === current_selection[2]))
        && ((d["clans_selected"][3] === current_selection[3]) || (d["clans_selected"][4] === current_selection[3]))
        && ((d["clans_selected"][3] === current_selection[4]) || (d["clans_selected"][4] === current_selection[4]))
    })
    const trials = _.filter(_.map(_.groupBy(dataset, (d) => d["clans_selected"][5]),(g,sixth_clan) => {
      let pct_p1_victory = p1VictoryPct(g)
      let selection_size = g.length
      if(bayesian_prior){
        pct_p1_victory = parseInt((parseFloat(p1VictoryPct(g))*g.length+trials_prior.pct*trials_prior.size)/(g.length+trials_prior.size))
        selection_size = g.length + trials_prior.size
      }

      return {
        clan_name: sixth_clan,
        selection_size,
        pct_p1_victory
      }
    }),(el) => el["selection_size"] > optimal_computation_min_dataset_size)


    if(trials.length < 1){
      return undefined
    }else{
      // max victory P2
      return _.sortBy(trials,(el) => -(100-el["pct_p1_victory"]))[0]
    }
  }
  function optimal_45th_clan_draft(data,current_selection,trials_prior,options = {}){
    const dataset = _.select(data,(d) => {
      return (d["clans_selected"][0] === current_selection[0]) 
        && ((d["clans_selected"][1] === current_selection[1]) || (d["clans_selected"][2] === current_selection[1]))
        && ((d["clans_selected"][1] === current_selection[2]) || (d["clans_selected"][2] === current_selection[2]))
    })
    const trials = _.filter(_.map(_.groupBy(dataset, (d) => [d["clans_selected"][3],d["clans_selected"][4]].sort()),(g,fourfifth_clan) => {
      return {
        fourfifth_clan: fourfifth_clan.split(","),
        best_scenario: optimal_6th_clan_draft(g,[...current_selection,...fourfifth_clan.split(",")],trials_prior,options)
      }
    }),(el) => el["best_scenario"] !== undefined)

    if(trials.length < 1){
      return undefined
    }else{
      // max victory P2
      return _.sortBy(trials,(el) => -(el["best_scenario"]["pct_p1_victory"]))[0] // max P1 victory
    }
  }
  function optimal_23th_clan_draft(data,current_selection,trials_prior,options = {}){
    const dataset = _.select(data,(d) => {
      return (d["clans_selected"][0] === current_selection[0]) 
    })
    const trials = _.filter(_.map(_.groupBy(dataset, (d) => [d["clans_selected"][1],d["clans_selected"][2]].sort()),(g,secondthird_clan) => {
      return {
        secondthird_clan: secondthird_clan.split(","),
        best_scenario: optimal_45th_clan_draft(g,[...current_selection,...secondthird_clan.split(",")],trials_prior,options)
      }
    }),(el) => el["best_scenario"] !== undefined)

    if(trials.length < 1){
      return undefined
    }else{
      // max victory P2
      return _.sortBy(trials,(el) => -(100-el["best_scenario"]["best_scenario"]["pct_p1_victory"]))[0] // max P1 victory
    }
  }

  function optimal_1st_clan_draft(data,trials_prior,options = {}){
    const trials = _.filter(_.map(_.groupBy(data, (d) => d["clans_selected"][0]),(g,first_clan) => {
      return {
        first_clan: first_clan,
        best_scenario: optimal_23th_clan_draft(g,[first_clan],trials_prior,options)
      }
    }),(el) => el["best_scenario"] !== undefined)

    if(trials.length < 1){
      return undefined
    }else{
      // max victory P2
      return _.sortBy(trials,(el) => -(100-el["best_scenario"]["best_scenario"]["best_scenario"]["pct_p1_victory"]))[0] // max P1 victory
    }
  }  

  function p1VictoryPct(data){
    const totElements = data.length;
    const p1wins = _.select(data,(d) => _.select(d["players"],(el) => el["is_first_player"])[0]["is_winner"]).length
    return parseInt(parseFloat(p1wins)/totElements*100)
  }

  // Initialize htm with Preact
  const html = htm.bind(h);

  function OptimalDraft(props){
    const prior_size = props.bayesian_prior ? props.trials_prior.size : 0
    if (props.clansSelected[0] === undefined){
      // draft with no knowledge
      const res = optimal_1st_clan_draft(props.data,props.trials_prior,{bayesian_prior: props.bayesian_prior})
      if (res === undefined){
        return html`<div>No optimal draft in data</div>`
      }else{
        return html `<table class="nice-table">
          <tr>
            <th></th>
            <th>P1</th>
            <th>P2</th>
          </tr>
          <tr>
            <td colspan="3">
              <i>
                ${res["best_scenario"]["best_scenario"]["best_scenario"]["selection_size"]-prior_size} games
              </i>
            </td>
          </tr>
          <tr>
            <td>Win</td>
            <td>${res["best_scenario"]["best_scenario"]["best_scenario"]["pct_p1_victory"]}%</td>
            <td>${100-res["best_scenario"]["best_scenario"]["best_scenario"]["pct_p1_victory"]}%</td>
          </tr>
          <tr>
            <td></td>
            <td class="nice ${clans_classes[res["first_clan"]]}">${res["first_clan"]}</td>
            <td class="nice ${clans_classes[res["best_scenario"]["secondthird_clan"][0]]}">
              ${res["best_scenario"]["secondthird_clan"][0]}
            </td>
          </tr>
          <tr>
            <td></td>
            <td class="nice ${clans_classes[res["best_scenario"]["best_scenario"]["fourfifth_clan"][0]]}">
              ${res["best_scenario"]["best_scenario"]["fourfifth_clan"][0]}
            </td>
            <td class="nice ${clans_classes[res["best_scenario"]["secondthird_clan"][1]]}">
              ${res["best_scenario"]["secondthird_clan"][1]}
            </td>
          </tr>
          <tr>
            <td></td>
            <td class="nice ${clans_classes[res["best_scenario"]["best_scenario"]["fourfifth_clan"][1]]}">
              ${res["best_scenario"]["best_scenario"]["fourfifth_clan"][1]}
            </td>
            <td class="nice ${clans_classes[res["best_scenario"]["best_scenario"]["best_scenario"]["clan_name"]]}">
              ${res["best_scenario"]["best_scenario"]["best_scenario"]["clan_name"]}
            </td>
          </tr>
        </table>`
      }
    }else if ((props.clansSelected[1] === undefined) || (props.clansSelected[2] === undefined)){
      // draft with already one clan
      const res = optimal_23th_clan_draft(props.data,[props.clansSelected[0]],props.trials_prior,{bayesian_prior: props.bayesian_prior})
      if (res === undefined){
        return html`<div>No optimal draft in data</div>`
      }else{
        return html `<table class="nice-table">
          <tr>
            <th></th>
            <th>P1</th>
            <th>P2</th>
          </tr>
          <tr>
            <td colspan="3">
              <i>
                ${res["best_scenario"]["best_scenario"]["selection_size"]-prior_size} games
              </i>
            </td>
          </tr>
          <tr>
            <td>Win</td>
            <td>${res["best_scenario"]["best_scenario"]["pct_p1_victory"]}%</td>
            <td>${100-res["best_scenario"]["best_scenario"]["pct_p1_victory"]}%</td>
          </tr>          
          <tr>
            <td></td>
            <td class="nice ${clans_classes[props.clansSelected[0]]}">${props.clansSelected[0]}</td>
            <td class="nice ${clans_classes[res["secondthird_clan"][0]]}">
              ${res["secondthird_clan"][0]}
            </td>
          </tr>
          <tr>
            <td></td>
            <td class="nice ${clans_classes[res["best_scenario"]["fourfifth_clan"][0]]}">
              ${res["best_scenario"]["fourfifth_clan"][0]}
            </td>
            <td class="nice ${clans_classes[res["secondthird_clan"][1]]}">
              ${res["secondthird_clan"][1]}
            </td>
          </tr>
          <tr>
            <td></td>
            <td class="nice ${clans_classes[res["best_scenario"]["fourfifth_clan"][1]]}">
              ${res["best_scenario"]["fourfifth_clan"][1]}
            </td>
            <td class="nice ${clans_classes[res["best_scenario"]["best_scenario"]["clan_name"]]}">
              ${res["best_scenario"]["best_scenario"]["clan_name"]}
            </td>
          </tr>
        </table>`
      }
    }else if ((props.clansSelected[3] === undefined) || (props.clansSelected[4] === undefined)){
      // draft with 3 clans already picked
      const res = optimal_45th_clan_draft(props.data,[props.clansSelected[0],props.clansSelected[1],props.clansSelected[2]],props.trials_prior,{bayesian_prior: props.bayesian_prior})
      if (res === undefined){
        return html`<div>No optimal draft in data</div>`
      }else{
        return html `<table class="nice-table">
          <tr>
            <th></th>
            <th>P1</th>
            <th>P2</th>
          </tr>
          <tr>
            <td colspan="3">
              <i>
                ${res["best_scenario"]["selection_size"]-prior_size} games
              </i>
            </td>
          </tr>
          <tr>
            <td>Win</td>
            <td>${res["best_scenario"]["pct_p1_victory"]}%</td>
            <td>${100-res["best_scenario"]["pct_p1_victory"]}%</td>
          </tr>
          <tr>
            <td></td>
            <td class="nice ${clans_classes[props.clansSelected[0]]}">${props.clansSelected[0]}</td>
            <td class="nice ${clans_classes[props.clansSelected[1]]}">
              ${props.clansSelected[1]}
            </td>
          </tr>
          <tr>
            <td></td>
            <td class="nice ${clans_classes[res["fourfifth_clan"][0]]}">
              ${res["fourfifth_clan"][0]}
            </td>
            <td class="nice ${clans_classes[props.clansSelected[2]]}">
              ${props.clansSelected[2]}
            </td>
          </tr>
          <tr>
            <td></td>
            <td class="nice ${clans_classes[res["fourfifth_clan"][1]]}">
              ${res["fourfifth_clan"][1]}
            </td>
            <td class="nice ${clans_classes[res["best_scenario"]["clan_name"]]}">
              ${res["best_scenario"]["clan_name"]}
            </td>
          </tr>
        </table>`
      }
    }else if (props.clansSelected[5] === undefined){
      // draft with 5 clans selected
      const res = optimal_6th_clan_draft(props.data,[props.clansSelected[0],props.clansSelected[1],props.clansSelected[2],props.clansSelected[3],props.clansSelected[4]],props.trials_prior,{bayesian_prior: props.bayesian_prior})
      if (res === undefined){
        return html`<div>No optimal draft in data</div>`
      }else{
        return html `<table class="nice-table">
          <tr>
            <th></th>
            <th>P1</th>
            <th>P2</th>
          </tr>
          <tr>
            <td colspan="3">
              <i>
                ${res["selection_size"]-prior_size} games
              </i>
            </td>
          </tr>
          <tr>
            <td>Win</td>
            <td>${res["pct_p1_victory"]}%</td>
            <td>${100-res["pct_p1_victory"]}%</td>
          </tr>
          <tr>
            <td></td>
            <td class="nice ${clans_classes[props.clansSelected[0]]}">${props.clansSelected[0]}</td>
            <td class="nice ${clans_classes[props.clansSelected[1]]}">
              ${props.clansSelected[1]}
            </td>
          </tr>
          <tr>
            <td></td>
            <td class="nice ${clans_classes[props.clansSelected[3]]}">
              ${props.clansSelected[3]}
            </td>
            <td class="nice ${clans_classes[props.clansSelected[2]]}">
              ${props.clansSelected[2]}
            </td>
          </tr>
          <tr>
            <td></td>
            <td class="nice ${clans_classes[props.clansSelected[4]]}">
              ${props.clansSelected[4]}
            </td>
            <td class="nice ${clans_classes[res["clan_name"]]}">
              ${res["clan_name"]}
            </td>
          </tr>
        </table>`
      }
    }else{
      return ""
    }
  }

  function StatsBoxPlot(props){
    const plot = useRef(null);

    useEffect(() => {
      const delayDebounceFn = setTimeout(() => {

        if(plot!==undefined &&  props.data !== undefined){
          let y = []
          let traceP1Winner = {
            x:[], 
            y:[],
            name: "p1 winner",
            marker: {color: '#00FF00'},
            type: 'box',
            boxmean: false,
            orientation: 'h'
          }
          let traceP1Loser = {
            x:[], 
            y:[],
            name:"p1 loser",
            marker: {color: '#FF0000'},
            type: 'box',
            boxmean: false,
            orientation: 'h'
          }
          let traceP2Winner = {
            x:[], 
            y:[],
            name: "p2 winner",
            marker: {color: '#00FF88'},
            type: 'box',
            boxmean: false,
            orientation: 'h'
          }
          let traceP2Loser = {
            x:[], 
            y:[],
            name:"p2 loser",
            marker: {color: '#FF0088'},
            type: 'box',
            boxmean: false,
            orientation: 'h'
          }
          stats.forEach((s) => {
            props.data.forEach((d) => {
              if(d["players"].filter((p) => p["is_winner"]).length === 1){
                if(d["players"][0]["is_winner"]){
                  if(d["players"][0]["is_first_player"]){
                    traceP1Winner.x.push(d["players"][0][s])
                    traceP1Winner.y.push(s)
                    traceP2Loser.x.push(d["players"][1][s])
                    traceP2Loser.y.push(s)                    
                  }else{
                    traceP1Loser.x.push(d["players"][0][s])
                    traceP1Loser.y.push(s)
                    traceP2Winner.x.push(d["players"][1][s])
                    traceP2Winner.y.push(s)                                      
                  }
                }else{
                  if(d["players"][0]["is_first_player"]){
                    traceP1Loser.x.push(d["players"][0][s])
                    traceP1Loser.y.push(s)
                    traceP2Winner.x.push(d["players"][1][s])
                    traceP2Winner.y.push(s)                                      
                  }else{
                    traceP1Winner.x.push(d["players"][0][s])
                    traceP1Winner.y.push(s)
                    traceP2Loser.x.push(d["players"][1][s])
                    traceP2Loser.y.push(s)                    
                  }
                }
              }
            })
          })

          const layout = {
            title: 'Play stats',
            boxmode: 'group',
            xaxis: {
              title: 'Statistic',
              zeroline: false
            },
          };

          Plotly.newPlot(plot.current, [traceP1Winner,traceP1Loser,traceP2Winner,traceP2Loser],layout);
        }


      }, 500)
      return () => clearTimeout(delayDebounceFn)
    },[plot,props.data])


    return html`<div style="width:100%;height:800px;">
        <div ref=${plot} style="width:100%;height:100%;"/>
      </div>
    ` 

  }

  function ChoicesChart(props){
    const el_id = _.uniqueId("mydiv-");

    useEffect(() => {
      const delayDebounceFn = setTimeout(() => {
        if(props.data !== undefined){
          const seuil = 0
          const choice_tree = {}
          let labels = ["Draft"]
          let ids = ["Draft"]
          let parents = [""]
          let colors = ["#ffffff"]
          let values = [props.data.length]
          _.map(_.groupBy(props.data,(el) => el["clans_selected"][0]),(gc1,c1) => {
              choice_tree[c1] = {size: gc1.length}
              if (gc1.length > seuil){
                labels.push(`${c1}`)
                ids.push(`${c1}`)
                parents.push(`Draft`)
                values.push(gc1.length)    
                colors.push(clans_colors[c1])

                const c23_by_size = _.map(_.sortBy(_.groupBy(_.flatten(_.map(gc1,(el) => [el["clans_selected"][1],el["clans_selected"][2]])),(el) => el),(v,k) => -v.length),(el) => el[0])

                _.map(_.groupBy(gc1,(el) => _.sortBy([el["clans_selected"][1],el["clans_selected"][2]],(c) => c23_by_size.indexOf(c))[0]),(gc2,c2) => {
                    choice_tree[c1][c2] = {size: gc2.length}
                    if (gc2.length > seuil){
                      labels.push(`${c2}`)
                      ids.push(`${c1}-${c2}`)
                      parents.push(`${c1}`)
                      values.push(gc2.length)      
                      colors.push(clans_colors[c2])
                    _.map(_.groupBy(gc2,(el) => _.sortBy([el["clans_selected"][1],el["clans_selected"][2]],(c) => c23_by_size.indexOf(c))[1]),(gc3,c3) => {
                      if (gc3.length > seuil){
                        choice_tree[c1][c2][c3] = {size: gc3.length}
                        labels.push(`${c3}`)
                        ids.push(`${c1}-${c2}-${c3}`)
                        parents.push(`${c1}-${c2}`)
                        values.push(gc3.length)
                        colors.push(clans_colors[c3])

                        const c34_by_size = _.map(_.sortBy(_.groupBy(_.flatten(_.map(gc3,(el) => [el["clans_selected"][3],el["clans_selected"][4]])),(el) => el),(v,k) => -v.length),(el) => el[0])

                        _.map(_.groupBy(gc3,(el) => _.sortBy([el["clans_selected"][3],el["clans_selected"][4]],(c) => c34_by_size.indexOf(c))[0]),(gc4,c4) => {
                          if (gc4.length > seuil){
                          choice_tree[c1][c2][c3][c4] = {size: gc4.length}
                          labels.push(`${c4}`)
                          ids.push(`${c1}-${c2}-${c3}-${c4}`)
                          parents.push(`${c1}-${c2}-${c3}`)
                          values.push(gc4.length)
                          colors.push(clans_colors[c4])
                          _.map(_.groupBy(gc4,(el) => _.sortBy([el["clans_selected"][3],el["clans_selected"][4]],(c) => c34_by_size.indexOf(c))[1]),(gc5,c5) => {
                            if(gc5.length > seuil){
                            choice_tree[c1][c2][c3][c4][c5] = {size: gc5.length}
                            labels.push(`${c5}`)
                            ids.push(`${c1}-${c2}-${c3}-${c4}-${c5}`)
                            parents.push(`${c1}-${c2}-${c3}-${c4}`)
                            values.push(gc5.length)
                            colors.push(clans_colors[c5])
                            _.map(_.groupBy(gc5,(el) => el["clans_selected"][5]),(gc6,c6) => {
                              if(gc6.length > seuil){
                              choice_tree[c1][c2][c3][c4][c5][c6] = {size: gc6.length}
                              labels.push(`${c6}`)
                              ids.push(`${c1}-${c2}-${c3}-${c4}-${c5}-${c6}`)
                              parents.push(`${c1}-${c2}-${c3}-${c4}-${c5}`)
                              values.push(gc6.length)
                              colors.push(clans_colors[c6])
                            }
                            })
                          }
                          })
                        }
                        })
                      }
                    })
                  }
                })    
              }
          })

          const data = [{
            type: "sunburst",
            ids,
            labels,
            parents,
            values,
            outsidetextfont: {size: 20, color: "#377eb8"},
            leaf: {opacity: 0.4},
            marker: {
              line: {width: 2},
              colors
            },
            "branchvalues": 'total'
          }];

          var layout = {
            margin: {l: 0, r: 0, b: 0, t: 0},
            width: 500,
            height: 500
          };


          Plotly.newPlot(el_id, data, layout);  
        }

      }, 500)




      return () => clearTimeout(delayDebounceFn)
    },[props.data])


    return html`<div style="width:100%;height:500px;">
        <div id=${el_id} style="width:100%;height:100%;"/>
      </div>
    ` 
  }


  function Clan (props) {
    const p1pct = p1VictoryPct(props.hypothesisData)

    return html `
      <div class="box ${props.clan_class} ${props.visible ? '' : "hidden"}">
        <div class="flex-row">
          <div>
            ${props.all_clans_selected ? '' : html `<button onClick=${(e) => props.selectClan(props.clan_name)}>select</button>`}
          </div>
          <div>
            ${props.ban_selected ? '' : html`<button onClick=${(e) => props.selectBan(props.clan_name)}>ban</button>`}            
          </div>
          <div>
            ${props.passives_selected ? '' : html `<button onClick=${(e) => props.selectPassive(props.clan_name)}>passive</button>`}
          </div>
        </div>
        <h1>${props.clan_name}</h1>
        <p>If next pick :</p1>
        <table class="nice-table">
          <tr>
            <th></th>
            <th>P1</th>
            <th>P2</th>
          </tr>
          <tr>
            <td>win</td>
            <td>${p1pct}%</td>
            <td>${100-p1pct}%</td>
          </tr>
          <tr>
            <td colspan="3">
              <small><i>
                picked in ${props.hypothesisData.length} games (${parseInt(parseFloat(props.hypothesisData.length)/props.datasetSize*100)}%)
              </i></small>
            </td>
          </tr>
          <tr>
            <td colspan="3">
              <small><i>
                ${props.hypothesisPassive === undefined ? '' : 
                  html `Passive in ${props.hypothesisPassive.length} (${parseInt(parseFloat(props.hypothesisPassive.length)/props.datasetSize*100)}%)`
                }
              </i></small>
            </td>
          </tr>
        </table>        
      </div>
    `    
  }

  function filterData({data,clanBanned,minElo,clansSelected,passives,pseudoSelected, pseudoSelectedFilter, pseudoSelectedPlayerOrder}){
    return _.filter(data,(el) => {
      return (el["average_rank"] >= minElo)
        && ((pseudoSelected === undefined) || (pseudoSelected === "") || (el["players"][0]["pseudo"] === pseudoSelected) ||  (el["players"][1]["pseudo"] === pseudoSelected))
        && ((pseudoSelected === undefined) || (pseudoSelected === "") || (pseudoSelectedFilter === "all") || ((pseudoSelectedFilter === "victories") && ((el["players"][0]["is_winner"] && el["players"][0]["pseudo"] === pseudoSelected) || (el["players"][1]["is_winner"] && el["players"][1]["pseudo"] === pseudoSelected))) || ((pseudoSelectedFilter === "defeats") && ((!el["players"][0]["is_winner"] && el["players"][0]["pseudo"] === pseudoSelected) || (!el["players"][1]["is_winner"] && el["players"][1]["pseudo"] === pseudoSelected))))
        && ((pseudoSelected === undefined) || (pseudoSelected === "") || (pseudoSelectedPlayerOrder === 0) || ((pseudoSelectedPlayerOrder === 1) && (((el["players"][0]["pseudo"] === pseudoSelected) && el["players"][0]["is_first_player"])) || ((el["players"][1]["pseudo"] === pseudoSelected) && el["players"][1]["is_first_player"])) || ((pseudoSelectedPlayerOrder === 2) && (((el["players"][0]["pseudo"] === pseudoSelected) && !el["players"][0]["is_first_player"])) || ((el["players"][1]["pseudo"] === pseudoSelected) && !el["players"][1]["is_first_player"])))
        && ((clanBanned.length === 0) || _.isEqual(clanBanned,el["clans_banned"]))
        && ((clansSelected[0] === undefined) || (el["clans_selected"][0] === clansSelected[0]))
        && ((clansSelected[1] === undefined) || (el["clans_selected"][1] === clansSelected[1]) || (el["clans_selected"][2] === clansSelected[1]))
        && ((clansSelected[2] === undefined) || (el["clans_selected"][1] === clansSelected[2]) || (el["clans_selected"][2] === clansSelected[2]))
        && ((clansSelected[3] === undefined) || (el["clans_selected"][3] === clansSelected[3]) || (el["clans_selected"][4] === clansSelected[3]))
        && ((clansSelected[4] === undefined) || (el["clans_selected"][3] === clansSelected[4]) || (el["clans_selected"][4] === clansSelected[4]))
        && ((clansSelected[5] === undefined) || (el["clans_selected"][5] === clansSelected[5]))
        && ((passives[0] === undefined) || (el["clan_passives"].indexOf(passives[0])) >= 0)
        && ((passives[1] === undefined) || (el["clan_passives"].indexOf(passives[1])) >= 0)
    })
  }

  function SampleLinks(props){
    if(props.data === undefined){
      return html``
    }
    const p1_win_sample = _.sample(
      props.data.filter((d) => {
        return ((d["players"][0]["is_winner"]) && (d["players"][0]["is_first_player"])) || ((d["players"][1]["is_winner"]) && (d["players"][1]["is_first_player"]))
      }),
      5
    )
    const p2_win_sample = _.sample(
      props.data.filter((d) => {
        return ((d["players"][0]["is_winner"]) && !(d["players"][0]["is_first_player"])) || ((d["players"][1]["is_winner"]) && !(d["players"][1]["is_first_player"]))
      }),
      5
    )
    const table_size = _.max([p1_win_sample === undefined ? 0 : p1_win_sample.length,p2_win_sample === undefined ? 0 : p2_win_sample.length])
    return html `<table class="bordered">
      <tr><th>P1 WIN</th><th>P2 WIN</th></tr>
      ${_.range(table_size).map((i) => {
        return html`<tr>
          <td>${p1_win_sample[i] === undefined ? '' : html`<a href="https://boardgamearena.com/table?table=${p1_win_sample[i]["id"]}" target="_blank">
            see game ${p1_win_sample[i]["id"]} on BGA </a>`}</td>
          <td>${p2_win_sample[i] === undefined ? '' : html`<a href="https://boardgamearena.com/table?table=${p2_win_sample[i]["id"]}" target="_blank"> 
            see game ${p2_win_sample[i]["id"]} on BGA </a>`}</td>
        </tr>`
      })}
    </table>`

  }

  function App (props) {
    const [minElo,setMinElo] = useState(100)
    const [selectedData,setSelectedData] = useState([])
    const [allData,setAllData] = useState([])
    const [datasetELO, setDatasetELO] = useState({min: 0, max: 500})
    const [clanBanned,setClanBanned] = useState([])
    const [clansSelected,setClanSelected] = useState([undefined,undefined,undefined,undefined,undefined,undefined])
    const [passives,setPassives] = useState([])
    const [pseudoSelected,setPseudoSelected] = useState("")
    const [pseudoSelectedFilter,setPseudoSelectedFilter] = useState("all")
    const [pseudoSelectedPlayerOrder,setPseudoSelectedPlayerOrder] = useState(0)
    const [bayesianPrior,setBayesianPrior] = useState(true)
    const [trialsPrior,setTrialsPrior] = useState({size: 0, pct: 50})    

    function removePassive(clan_name){
      setPassives(passives.filter((el) => el !== clan_name))
    }

    function addClanToSelection(clan_name){
      const nextIndex = clansSelected.indexOf(undefined)
      let newClans = [...clansSelected]
      newClans[nextIndex] = clan_name
      return newClans   
    }
    function selectClan(clan_name){
      setClanSelected(addClanToSelection(clan_name))
    }
    function removeClan(clan_name){
      let newClans = [...clansSelected]
      const i = clansSelected.indexOf(clan_name)
      newClans[i] = undefined
      setClanSelected(newClans)
    }
    function ClanSelected({clan_name, removeClan}){
      if(clan_name === undefined){
        return html`<div></div>`
      }else{
        return html `<div class="box ${clans_classes[clan_name]}">
          ${clan_name}
          <button onClick=${(e) => removeClan(clan_name)}>remove</button>
        </div>`
      }        
    }


    useEffect(async () => {
      const response = await fetch("data.json");
      setAllData(await response.json());
    },[])
    useEffect(() => {
      // set min elo so that we have at least 1000 entries
      if (allData.length > 1000){
        setMinElo(_.sortBy(allData,(el) => -el["average_rank"])[1000]["average_rank"])
      }
    },[allData])
    useEffect(() => {
      setSelectedData(filterData({data:allData,clanBanned,minElo,clansSelected,passives,pseudoSelected, pseudoSelectedFilter, pseudoSelectedPlayerOrder}))
      setDatasetELO({
        min: _.min(_.map(allData, (el) => el["average_rank"])),
        max: _.max(_.map(allData, (el) => el["average_rank"]))
      })
    }, [allData,minElo,clanBanned,clansSelected,passives,pseudoSelected, pseudoSelectedFilter, pseudoSelectedPlayerOrder])
    useEffect(() => {
      setTrialsPrior({size: parseInt(selectedData.length/5), pct: p1VictoryPct(selectedData)})
    },[selectedData])

    return html`
      <div class="nice flex-row navbar sticky">
        <div>
          Number of games: ${selectedData.length} / ${allData.length}
          <a class="nice" href="/data.csv" download="data.csv">
            CSV
          </a>
          <a class="nice" href="/data.json" download="data.json">
            JSON
          </a>
          <input placeholder="pseudo" value="${pseudoSelected}" onInput=${(e) => setPseudoSelected(e.currentTarget.value)}/>
          <select value=${pseudoSelectedFilter} onChange=${(e) => setPseudoSelectedFilter(e.currentTarget.value)}>
            <option value="all">all</option>
            <option value="victories">victories</option>
            <option value="defeats">defeats</option>
          </select>
          <select value="${pseudoSelectedPlayerOrder}" onChange=${(e) => setPseudoSelectedPlayerOrder(parseInt(e.currentTarget.value))}>
            <option value="0">all</option>
            <option value="1">First player</option>
            <option value="2">Second player</option>
          </select>
        </div>
        <div class="flex-row">
          <div>
            ELO > ${minElo}
          </div>
          <div class="slidecontainer">
            <input 
              type="range" 
              min="${datasetELO.min}" 
              max="${datasetELO.max}" 
              value="${minElo}" 
              class="slider" 
              onInput=${(e) => {setMinElo(e.currentTarget.value)}}
              />
          </div>
        </div>
      </div>
<div class="container flex-row">
  <div class="flex-column left-panel nice">
    ${_.map(_.groupBy([
        {clan_class:"xian",clan_name: "Xi'an"},
        {clan_class:"narashima",clan_name: "Narashima"},
        {clan_class:"abhilasha",clan_name: "Abhilasha"},
        {clan_class:"galmi",clan_name: "Galmi"},
        {clan_class:"tomorrow",clan_name: "Tomorrow"},
        {clan_class:"goan-sul",clan_name: "Goan-Sul"},
        {clan_class:"justice",clan_name: "Justice"},
        {clan_class:"phoenix",clan_name: "Phoenix"},
        {clan_class:"abunakkashii",clan_name: "Abunakkashii"}
      ], (el,i) => parseInt(i/3)), (g) => {
      return html`<div class="flex-row nice">
        ${g.map((el) => {
          if(el ===undefined){
            return html`<div></div>`
          }else{
            return html`
            <${Clan} 
              clan_class=${el.clan_class} 
              clan_name=${el.clan_name}
              ban_selected=${clanBanned.length > 0} 
              selectBan=${(c) => setClanBanned([c])}
              selectClan=${(c) => selectClan(c)}
              visible=${
                (clanBanned.indexOf(el.clan_name) < 0) 
                && (clansSelected.indexOf(el.clan_name) < 0)
                && (passives.indexOf(el.clan_name) < 0)
              }
              hypothesisData=${filterData({data:selectedData,clanBanned,minElo,clansSelected:addClanToSelection(el.clan_name),passives, pseudoSelected, pseudoSelectedFilter, pseudoSelectedPlayerOrder})}
              hypothesisPassive=${
                passives.length === 2 ? 
                  undefined :
                  filterData({data:selectedData,clanBanned,minElo,clansSelected,passives:[...passives,el.clan_name],pseudoSelected, pseudoSelectedFilter, pseudoSelectedPlayerOrder})
              }
              all_clans_selected=${clansSelected.indexOf(undefined) < 0}
              datasetSize=${selectedData.length}
              passives_selected=${passives.length === 2}
              selectPassive=${(c) => setPassives([...passives,c])}
            />`
          }
        })}
      </div>`
    })}
  </div>
  <div class="right-panel flex-col nice">
    <div class="flex-row">
      <div id="first-player-picks" class="flex-column nice">
        <div>
          <h1>P1</h1>
          <p>${p1VictoryPct(selectedData)}% WIN</p>
        </div>
        <div id="first-player-pick1" class="flex-column border  min-100">
          <${ClanSelected} clan_name=${clansSelected[0]} removeClan=${removeClan}/>         
        </div>
        <div id="first-player-pick2" class="flex-column border grow-2  min-200">
          <${ClanSelected} clan_name=${clansSelected[3]} removeClan=${removeClan}/>         
          <${ClanSelected} clan_name=${clansSelected[4]} removeClan=${removeClan}/>         
        </div>
      </div>
      <div id="second-player-picks" class="flex-column nice">
        <div>
          <h1>P2</h1>
          <p>${100-p1VictoryPct(selectedData)}% WIN</p>
        </div>
        <div id="second-player-pick1" class="flex-column border grow-2 min-200">
          <${ClanSelected} clan_name=${clansSelected[1]} removeClan=${removeClan}/>         
          <${ClanSelected} clan_name=${clansSelected[2]} removeClan=${removeClan}/>         
        </div>
        <div id="second-player-pick2" class="flex-column border  min-100">
          <${ClanSelected} clan_name=${clansSelected[5]} removeClan=${removeClan}/>         
        </div>
      </div>
    </div>
    <div>
      <h3>Banned</h3>
      ${clanBanned.map((clan_name) => {
        return html`
          <div class="box ${clans_classes[clan_name]}">
            ${clan_name}
            <button onClick=${(e) => setClanBanned([])}>Unban</button>
          </div>   
        `
      })}
    </div>
    <div>
      <h3>Victory conditions</h3>
      <ul>
        ${_.map(
            _.sortBy(
              _.map(
                _.groupBy(
                  selectedData,
                  (d) => d.victory_condition
                ), 
                (v,k) => {
                  return {nb: v.length, name: k}
                }
              ), 
              (el) => - el.nb
            ), 
            (el) => {
              return html`<li> ${el.name} : ${parseInt(parseFloat(el.nb)/selectedData.length*100)}% (${el.nb}) </li>`
            }
        )}
      </ul>
    </div>
    <div>
      <h3>Passives</h3>
      <div class="flex-row">
        ${passives.map((clan_name) => {
          return html`
            <div class="box ${clans_classes[clan_name]}">
              ${clan_name}
              <button onClick=${(e) => removePassive(clan_name)}>remove</button>
            </div>   
          `
        })}
      </div>
    </div>
    <div>
      <h3>Example Games</h3>
      <${SampleLinks} data=${selectedData}/>
    </div>
    <div>
      <h3>Optimal Draft 
        <small class="pull-right">
          <i>
            Prior (${trialsPrior.size} games, p1 ${trialsPrior.pct}% win)
            <input type="checkbox" checked=${bayesianPrior ? "checked" : ""} onClick=${(e) => setBayesianPrior(!bayesianPrior)}/>
          </i>
        </small>
      </h3>
      <${OptimalDraft} 
        data=${selectedData} 
        clansSelected=${clansSelected} 
        bayesian_prior=${bayesianPrior} 
        trials_prior=${trialsPrior}/>
    </div>
  </div>
</div>
<div class="flex-row">
  <div class="flex-column">
    <h3>Player 1 winner draft</h3>
    <${ChoicesChart} data=${selectedData.filter((d) => 
      (d["players"][0]["is_first_player"] && d["players"][0]["is_winner"]) 
      || (d["players"][1]["is_first_player"] && d["players"][1]["is_winner"]))}/>
  </div>
  <div class="flex-column">
    <h3>Player 2 winner draft </h3>
    <${ChoicesChart} data=${selectedData.filter((d) => 
      (d["players"][0]["is_first_player"] && d["players"][1]["is_winner"]) 
      || (d["players"][1]["is_first_player"] && d["players"][0]["is_winner"]))}/>
  </div>
</div>
  <${StatsBoxPlot} data=${selectedData}/>
    `;
  }

  render(html`<${App} name="World" />`, document.body);
</script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HMX9HK6HQM"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HMX9HK6HQM');
</script>
</body>
</html>